# -*- coding: utf-8 -*-
"""BitVectorDemo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NoLVEBqkvrHwoYoEuxX0BeJvaJ5MtVrA
"""
import random
import math
import libnum
import timeit
"""Tables"""

from BitVector import *
Sbox = (
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
)

InvSbox = (
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,
)

Mixer = [
    [BitVector(hexstring="02"), BitVector(hexstring="03"), BitVector(hexstring="01"), BitVector(hexstring="01")],
    [BitVector(hexstring="01"), BitVector(hexstring="02"), BitVector(hexstring="03"), BitVector(hexstring="01")],
    [BitVector(hexstring="01"), BitVector(hexstring="01"), BitVector(hexstring="02"), BitVector(hexstring="03")],
    [BitVector(hexstring="03"), BitVector(hexstring="01"), BitVector(hexstring="01"), BitVector(hexstring="02")]
]

InvMixer = [
    [BitVector(hexstring="0E"), BitVector(hexstring="0B"), BitVector(hexstring="0D"), BitVector(hexstring="09")],
    [BitVector(hexstring="09"), BitVector(hexstring="0E"), BitVector(hexstring="0B"), BitVector(hexstring="0D")],
    [BitVector(hexstring="0D"), BitVector(hexstring="09"), BitVector(hexstring="0E"), BitVector(hexstring="0B")],
    [BitVector(hexstring="0B"), BitVector(hexstring="0D"), BitVector(hexstring="09"), BitVector(hexstring="0E")]
]
# def string_to_hex(input_string):
    
#     # hex_list = [).get_bitvector_in_hex() for char in input_string]
#     return hex_list
rchex = ["0", "01", "02", "04", "08", "10", "20", "40", "80", "1B", "36"]
fixed_mat = [["02", "03", "01", "01"], ["01", "02", "03", "01"], ["01", "01", "02", "03"], ["03", "01", "01", "02"]]
inv_fixed_mat = [["0E", "0B", "0D", "09"], ["09", "0E", "0B", "0D"], ["0D", "09", "0E", "0B"], ["0B", "0D", "09", "0E"]]
hex_digits = ['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f']

AES_modulus = BitVector(bitstring='100011011')
rc = []
for i in range (0, len(rchex)):
    rc.append(BitVector(hexstring = rchex[i]))

# def numtostr(x):
#     s = str(x)
#     lst = []
#     for i in range(0, len(s), 2):
#         t = ""
#         for j in range(i, i + 2):
#             t += s[i]
#         lst.append(t)
#     return hexlisttostr(lst)

def strtohexlist(s):
    ret = []
    for i in range(0, len(s), 2):
        t = ""
        for j in range(i, i + 2):
            t += s[j]
        ret.append(t)
    return ret
def hexlisttostr(lst):
    ret = ""
    for x in lst:
        ret += x
    return ret

def mattolist(mat):
    ret = []
    for w in mat:
        for x in w:
            ret.append(x)
    return ret
def listtomat(message):
    nm = []
    # # # print(" message length = " + str(len(message)))
    for i in range(0, len(message), 4):
        t = []
        for j in range(i, i + 4):
            t.append(message[j])
        nm.append(t)
    return nm
def iv_gen():
    ret = [];
    for i in range(0, 16):
        s = hex_digits[random.randint(0, 15)] + hex_digits[random.randint(0, 15)]
        ret.append(s)
    return ret

def byteSubstitution(hex_list):
    for i in range (0, len(hex_list)):
        b = BitVector(hexstring=hex_list[i])
        int_val = b.intValue()
        s = Sbox[int_val]
        s = BitVector(intVal=s, size=8)
        hex_list[i] = s.get_bitvector_in_hex()
    return hex_list

def invbyteSubstitution(hex_list):
    for i in range (0, len(hex_list)):
        b = BitVector(hexstring=hex_list[i])
        int_val = b.intValue()
        s = InvSbox[int_val]
        s = BitVector(intVal=s, size=8)
        hex_list[i] = s.get_bitvector_in_hex()
    return hex_list

def hex_str_xor(x, y) :
    ret = []
    for i in range(0, len(x)):
        ret.append((BitVector(hexstring=x[i]) ^ BitVector(hexstring=y[i])).get_bitvector_in_hex())
    return ret

def iv_xor(x, iv):
    # # # print("================================================")
    # # # print(x)
    # # # print("ivvvvvvvvvvvvvvvvvvvvvvvvvvvvv")
    # # # print(iv)
    # # # print("doooooooooooooone")
    ret = ""
    for i in range(0, len(x)):
        c = x[i]
        d = iv[i]
        s = BitVector(intVal=ord(c), size=8) ^ BitVector(hexstring=d)
        ret += s.get_bitvector_in_ascii()
    return ret
def matxor(x, y):
    ret = []
    for i in range(0, len(x)):
        ret.append(hex_str_xor(x[i], y[i]))
    return ret
# b = 
def matincleftshift(mat):
    for i in range(0, len(mat)):
        mat[i] = mat[i][i:] + mat[i][:i]
    return mat

def matincrightshift(mat):
    for i in range(0, len(mat)):
        j = len(mat) - i
        mat[i] = mat[i][j:] + mat[i][:j]
    return mat

def strtomat(k):
    w = []
    for i in range (0, len(k), 4):
        t = []
        for j in range (i, i + 4):
            c = k[j]
            s = BitVector(intVal=ord(c), size=8)
            t.append(s.get_bitvector_in_hex())
        w.append(t)
    return w

def hex_strtomat(k):
    # print(len(k))
    w = []
    for i in range (0, len(k), 4 * 2):
        c = ""
        for j in range (i, i + 4 * 2):
            c += k[j]
        w.append(strtohexlist(c))
    return w

def mattostr(w):
    ret = ""
    for i in range (0, len(w)):
        t = w[i]
        for tt in t:
            s = BitVector(hexstring=tt).get_bitvector_in_ascii()
            ret += s
    return ret


def rotatemat(mat):
    nmat = []
    for i in range(0, len(mat[0])) :
        t = []
        for j in range(0, len(mat)):
            t.append(mat[j][i])
        nmat.append(t)
    return nmat

def matmulti(mat1, mat2):
    ret = []
    for i in range(0, len(mat1)):
        t = []
        for j in range(0, len(mat2[0])):
            c = BitVector(hexstring="00")
            for k in range(0, len(mat1[0])):
                a = BitVector(hexstring=mat1[i][k])
                b = BitVector(hexstring=mat2[k][j])
                # # # print(a.get_bitvector_in_hex() + "     xx     " + b.get_bitvector_in_hex())
                a = a.gf_multiply_modular(b, AES_modulus, 8)
                c = c ^ a
            t.append(c.get_hex_string_from_bitvector())
        ret.append(t)
    return ret

def AES_encrypt(key, message, iv):
    # # # print(len(message))
    # print("message in aeeeeeeeeeeeees ")
    message = iv_xor(message, iv)
    # print("messsssssssage after xor ")
    # bv1 = BitVector(hexstring="02")
    # bv2 = BitVector(hexstring="63")
    # bv3 = bv1.gf_multiply_modular(bv2, AES_modulus, 8)
    # # # print(bv3)
    w = hex_strtomat(key)
    
    for i in range (4, 44, 4) :
        gw = w[i - 1][1:] + w[i - 1][:1]
        gw = byteSubstitution(gw)
        gw[0] = (BitVector(hexstring=gw[0]) ^ rc[int(i / 4)]).get_bitvector_in_hex()
        w.append(hex_str_xor(gw, w[i - 4]))
        for j in range(i + 1, i + 4):
            w.append(hex_str_xor(w[j - 4], w[j - 1]))

    curIt = 0
    # message = "Two One Nine Two"
    mat = strtomat(message)
    wit = w[curIt * 4 : curIt * 4 + 4]
    mat = rotatemat(mat)
    wit = rotatemat(wit)
    # # # print(mat)
    # # # print(wit)

    state_mat = matxor(mat, wit)

    for curIt in range(1, 11):
        for i in range (0, len(state_mat)):
            state_mat[i] = byteSubstitution(state_mat[i])
        state_mat = matincleftshift(state_mat)
        #mix column
        if (curIt < 10):
            state_mat = matmulti(fixed_mat, state_mat)
        # # # print(state_mat)
        wit = w[curIt * 4 : curIt * 4 + 4]
        wit = rotatemat(wit)
        # # # print(wit)
        # round key
        state_mat = matxor(state_mat, wit)
        # if (curIt == 10):
            # # print(state_mat)
        # # print("encrypteeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee")
    return hexlisttostr(mattolist(state_mat))
def AES_decrypt(key, message, iv):
    w = hex_strtomat(key)
    message = listtomat(strtohexlist(message))

    for i in range (4, 44, 4) :
        gw = w[i - 1][1:] + w[i - 1][:1]
        gw = byteSubstitution(gw)
        gw[0] = (BitVector(hexstring=gw[0]) ^ rc[int(i / 4)]).get_bitvector_in_hex()
        w.append(hex_str_xor(gw, w[i - 4]))
        for j in range(i + 1, i + 4):
            w.append(hex_str_xor(w[j - 4], w[j - 1]))
    curIt = 10
    mat = message
    wit = w[curIt * 4 : curIt * 4 + 4]
    # mat = rotatemat(mat)
    wit = rotatemat(wit)
    state_mat = matxor(mat, wit)
    
    for curIt in range(9, -1, -1):
        state_mat = matincrightshift(state_mat)
        for i in range (0, len(state_mat)):
            state_mat[i] = invbyteSubstitution(state_mat[i])
        wit = w[curIt * 4 : curIt * 4 + 4]
        wit = rotatemat(wit)
        # # # print(wit)
        # round key
        state_mat = matxor(state_mat, wit)
        if (curIt > 0):
            state_mat = matmulti(inv_fixed_mat, state_mat)
    state_mat = rotatemat(state_mat)
    # # # print("here in string ")
    ret = iv_xor(mattostr(state_mat), iv)
    # # # print("retttt")
    # # # print(ret)
    # # # print(mattostr(state_mat))
    return ret


def make_chunk(message, size = 16):
    total_chunks = (len(message) + size - 1) // size
    ret = []
    for i in range(total_chunks):
        s = message[i * size: i * size + size]
        ret.append(s.ljust(size))
    return ret
def CBC_encrypt(key, message, iv):
    # print("inside encryyyypt")
    chunks = make_chunk(message=message, size=16)
    # print(chunks)
    cipher_list=[]
    cipher_list.append(AES_encrypt(key, chunks[0], iv))
    # print("after chunk lissssssssssssssst ")
    for i in range (1, len(chunks)):
        niv = cipher_list[-1]
        cipher_list.append(AES_encrypt(key, chunks[i], niv))
    # print("encryption compleeeeeeeeeeeeeete")
    return cipher_list

def CBC_decrypt(key, cipher_list, iv):
    plain_text = []
    # # # print(cipher_list)
    plain_text.append(AES_decrypt(key, cipher_list[0], iv))
    for i in range(1, len(cipher_list)):
        plain_text.append(AES_decrypt(key, cipher_list[i], cipher_list[i - 1]))
    return plain_text;


def is_solvable(n, p) :
    # # # print("solvableeeeeeeeeeeeeeeeeeeeeeeeeeeeeee")
    ret = False
    if (n % p == 0):
        ret = True
    elif pow(n, (p - 1)//2, p) == 1:
        ret = True
    # # # print("in lastttttttttttttttttttt")
    return ret

def tonelli_shanks(p, n):
    # # # print("insideeeeeeeeeeeeeeeeeeeeeeeeeeeeee")
    if (n % p == 0):
        # # # print("ret 0000000000000000000000000000")
        return 0
    if not is_solvable(n, p):
        # # print("Not quad residue")
        return None
    if (p % 4 == 3):
        # # # print("retttttttttttttttttttttttttttttttttttttt")
        return pow(n, (p + 1) // 4, p)
    S = 0
    Q = p - 1
    # # # print("in whileeeeeeeeeeeeeeeeeeeeeeee ")
    while Q % 2 == 0:
        # # # print("qqqqqqqqqqqqq = ", Q)
        Q = Q // 2
        S = S + 1
    # # print("Q = ", Q)
    # # print("S = ", S)

    z = 2
    while is_solvable(z, p):
        z = z + 1
    # # print("z = ", z)
    M = S
    c = pow(z, Q, p)
    t = pow(n, Q, p)
    R = pow(n, (Q + 1) // 2, p)

    while t != 1:
        # # print("LOOP")
        i = 0
        temp = t
        while temp != 1:
            i = i + 1
            temp = (temp * temp) % p
        # # print("i = ", i)

        pow2 = 2 ** (M - i - 1)
        M = i
        b = pow(c, pow2, p)
        c = (b * b) % p
        t = (t * b * b) % p
        R = (R * b) % p

    return R
    
        
def get_y_value_elliptic_curve(p, a, b, x):
	return tonelli_shanks(p, (x * x * x + a * x + b) % p)

# # The Elliptic Curve P-224
# p = 26959946667150639794667015087019630673557916260026308143510066298881 
# a = -3
# b = int('b4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4', 16)

# # Make up a random number x and calculate y (if it exists)
# x = 2021
# y = get_y_value_elliptic_curve(p, a, b, x)

# if (y == None):
#     exit()


# check that point is indeed on the elliptic curve
# if (y * y - (x * x * x + a * x + b)) % p == 0:
# 	# # print("(", x, ",", y, ")")
# 	# # print("Point has been verified to be on the elliptic curve!")


def gcdExtended(a, b): 
    # Base Case 
    if a == 0 : 
        return b,0,1
             
    gcd,x1,y1 = gcdExtended(b%a, a) 
     
    # Update x and y using results of recursive 
    # call 
    x = y1 - (b//a) * x1 
    y = x1 
     
    return gcd,x,y 

def pinverse(a, m):
    g, x, y = gcdExtended(a, m)
    if (g == 1):
        return x % m
    else:
        return 0

def mod(a, b):
    m = a % b
    if (b < 0 and m < 0):
        m -= b
    elif(b > 0 and m < 0):
        m += b
    return m

def pdoubling(x, y, p, a, b):
    s = mod(mod(3 * x * x + a, p) * pinverse(mod(2 * y, p), p), p)
    retx = mod(s * s - 2 * x, p)
    rety = mod(s * (x - retx) - y, p)
    return retx, rety

def padd(x1, y1, x2, y2, p, a, b):
    if (x1 != x2 or y1 != y2):
        s = mod(mod(y2 - y1, p) * pinverse(mod(x2 - x1, p), p), p)
        retx = mod(mod(s * s, p) - x1 - x2, p)
        rety = mod(mod(s * (x1 - retx), p) - y1, p)
        return retx, rety
    return pdoubling(x1, y1, a, b)

def genG(a, b, p):
    while True:
        x = random.randint(1, p - 1)
        y = get_y_value_elliptic_curve(p, a, b, x)
        if (y != None):
            return x, y

def pmultiply(x, y, coeff, p, a, b):
    bits = BitVector(intVal=coeff)
    retx = x
    rety = y
    for i in range(1, len(bits)):
        retx, rety = pdoubling(retx, rety, p, a, b)
        if (bits[i] == 1):
            retx, rety = padd(retx, rety, x, y, p, a, b)
    return retx, rety
# a = 2 
# b = 2
# p = 17
def genP(total_bits):
    return libnum.generate_prime(total_bits)
def genE(p):
    return p + 1 - 2 * math.ceil(math.sqrt(p))

def genab(p):
    while True:
        a = random.randint(1, p - 1)
        b = random.randint(1, p - 1)
        if (mod(4 * a * a * a + 27 * b * b, p) == 0):
             continue
        return a, b
def genk(E):
    return random.randint(1, E - 1)

def keytesting():
    print("Average time in seconds for different size of keys")
    bitlist = [128, 192, 256]
    
    for bit in bitlist:
        ta = []
        tb = []
        tshared = []
        for i in range(5):
            p = genP(bit)
            a, b = genab(p)
            g = genG(a, b, p)
            E = genE(p)
            ka = genk(E)
            kb = genE(p)
            start_time = timeit.default_timer()
            kag = pmultiply(g[0], g[1], ka, p, a, b)
            end_time = timeit.default_timer()
            ta.append(end_time - start_time)
            start_time = timeit.default_timer()
            kbg = pmultiply(g[0], g[1], kb, p, a, b)
            end_time = timeit.default_timer()
            tb.append(end_time - start_time)
            start_time = timeit.default_timer()
            kakbbg = pmultiply(kag[0], kag[1], kb, p, a, b)
            end_time = timeit.default_timer()
            tshared.append(end_time - start_time)
        avgta = sum(ta) / 5
        avgtb = sum(tb) / 5
        avgtshared = sum(tshared) / 5
        print(str(bit) + " : A = " + str(avgta) + " B = " + str(avgtb) + " R = " + str(avgtshared))

        # iv = iv_gen()
# p = genP()
# a, b = genab(p)
# # # print("prime ========== ", genG(a, b, p))